#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Make final quark mass table at μ* using QCD(4L)+QED(2L) and the same fixed-point as leptons.
Outputs:
  out/csv/quark_masses_muStar.csv
  out/tex/quark_masses_muStar.tex
No per-species knobs; all changes are global.


Conventions:
  a_s = α_s / π   (for γ_m)
  α_s running uses a4 = α_s / (4π) in β_s(a4) form (standard in QCD literature).
  We convert between a_s and a4 consistently inside helpers below.
"""


import os, csv, math


# -------- Sector constants (frozen) and integers r_i (structural) --------
PHI   = (1.0 + 5.0**0.5)/2.0
LNPHI = math.log(PHI)
ECOH_eV  = PHI**(-5.0)         # exact φ^-5 eV
ECOH_GeV = ECOH_eV * 1e-9


# Up sector (B_U, r0(U)) = (2^{-1}, 35) ; Down sector (B_D, r0(D)) = (2^{23}, -5)
A_U = (2.0 ** (-1)) * ECOH_GeV * (PHI ** 35)
A_D = (2.0 ** (23)) * ECOH_GeV * (PHI ** (-5))


R_UP = {'u': 4, 'c': 15, 't': 21}
R_DN = {'d': 4, 's': 15, 'b': 21}
Q_UP = {'u': +2.0/3.0, 'c': +2.0/3.0, 't': +2.0/3.0}
Q_DN = {'d': -1.0/3.0, 's': -1.0/3.0, 'b': -1.0/3.0}


# PDG reference masses for table comparison (GeV) — MSbar at μ*=2 GeV for u,d,s; m_c(m_c); m_b(m_b)
PDG = {
    'u': {'mu_star': 2.0,    'ref': 0.00216},  # m_u(2 GeV)
    'd': {'mu_star': 2.0,    'ref': 0.00467},  # m_d(2 GeV)
    's': {'mu_star': 2.0,    'ref': 0.09300},  # m_s(2 GeV)
    'c': {'mu_star': 1.27,   'ref': 1.27},     # m_c(m_c)
    'b': {'mu_star': 4.18,   'ref': 4.18},     # m_b(m_b)
    # 't': {'mu_star': 172.69,'ref': 172.69},  # top (pole) — add when you want to print top
}


# Electroweak inputs (frozen; QED used at 2L as small correction)
ALPHA_mZ = 1.0 / 127.955  # α(mZ)
MZ_GeV   = 91.1876


# --------------- 4-loop QCD β-function (SU(3)) in a4 = αs/(4π) ---------------
# μ da4/dμ = - β0 a4^2 - β1 a4^3 - β2 a4^4 - β3 a4^5  (MSbar)
ZETA3 = 1.2020569031595942
def beta_coeffs_4L(nf: int):
    b0 = 11.0 - 2.0/3.0 * nf
    b1 = 102.0 - 38.0/3.0 * nf
    b2 = 2857.0/2.0 - 5033.0/18.0 * nf + 325.0/54.0 * nf*nf
    b3 = (149753.0/6.0 + 3564.0*ZETA3) \
         - (1078361.0/162.0 + 6508.0/27.0*ZETA3)*nf \
         + (50065.0/162.0 + 6472.0/81.0*ZETA3)*nf*nf \
         + (1093.0/729.0)*nf*nf*nf
    return b0, b1, b2, b3


def run_alpha_s_4L(mu_lo, mu_hi, alpha_s_lo, nf):
    """
    Evolve αs(μ) from μ_lo to μ_hi with 4L β in a4 = αs/(4π) by RK4 on ln μ.
    Assumes nf fixed on the interval (decoupling handled outside).
    """
    def step_as(a4, dlnmu):
        b0,b1,b2,b3 = beta_coeffs_4L(nf)
        # β in a4 form
        def beta_a4(a):
            return - (b0*a*a + b1*a*a*a + b2*a*a*a*a + b3*a*a*a*a*a)
        # RK4 in log μ
        k1 = beta_a4(a4)
        k2 = beta_a4(a4 + 0.5*dlnmu*k1)
        k3 = beta_a4(a4 + 0.5*dlnmu*k2)
        k4 = beta_a4(a4 + dlnmu*k3)
        return a4 + (dlnmu/6.0)*(k1 + 2*k2 + 2*k3 + k4)


    a4 = alpha_s_lo / (4.0*math.pi)
    nstep = max(200, int(abs(math.log(mu_hi/mu_lo))*800))
    sgn   = 1.0 if mu_hi>mu_lo else -1.0
    dln   = sgn*abs(math.log(mu_hi/mu_lo))/nstep
    mu    = mu_lo
    for _ in range(nstep):
        mu = mu*math.exp(dln)
        a4 = step_as(a4, dln)
        a4 = max(min(a4, 0.5), 1e-6)  # keep in a safe numeric window
    return (4.0*math.pi)*a4


# --------------- 4-loop QCD mass anomalous dimension in a_s = αs/π ---------------
# γ_m(a_s) = - (γ0 a + γ1 a^2 + γ2 a^3 + γ3 a^4)
def gamma_m_qcd_4L(a_s: float, nf: int) -> float:
    g0 = 1.0
    g1 = (101.0/24.0) - (5.0/36.0)*nf
    g2 = (1249.0/64.0) - (277.0/216.0)*nf - (35.0/1296.0)*nf*nf
    g3 = (4603055.0/41472.0 + (41.0/18.0)*ZETA3) \
         - ((91723.0/20736.0) + (11.0/12.0)*ZETA3)*nf \
         + (151.0/162.0)*nf*nf + (5.0/972.0)*nf*nf*nf
    return - (g0*a_s + g1*a_s*a_s + g2*a_s*a_s*a_s + g3*a_s*a_s*a_s*a_s)


# --------------- 2-loop QED mass anomalous dimension (small, global) -------------
def gamma_m_qed_2L(alpha_em: float, Qq: float) -> float:
    a = alpha_em / math.pi
    return - (3.0*Qq*Qq*a + 1.5*(Qq**4)*a*a)


# --------------- Decoupling policy (nf profile) ----------------------------------
def nf_profile(mu: float) -> int:
    """Active flavours at scale μ (GeV). Add top threshold if you print top now."""
    if mu < 1.27:     # below m_c
        return 3
    elif mu < 4.18:   # between m_c and m_b
        return 4
    else:
        return 5      # add 6 if you include top and cross mt


# --------------- αs(μ) with fixed decoupling at m_c,m_b --------------------------
def alpha_s_MSbar(mu: float, alpha_s_mZ: float = 0.1179) -> float:
    """
    Piecewise running with nf fixed on sub-intervals:
      (mZ -> m_b) nf=5, (m_b -> m_c) nf=4, (m_c -> μ) nf=3 (or reverse if going up).
    """
    # Start at mZ with nf=5
    cur_mu = MZ_GeV
    cur_as = alpha_s_mZ
    if mu == MZ_GeV:
        return cur_as


    # Helper to run between two scales with a fixed nf
    def run_between(mu_lo, mu_hi, as_lo, nf):
        return run_alpha_s_4L(mu_lo, mu_hi, as_lo, nf)


    # Define thresholds
    mc, mb = 1.27, 4.18


    path = []
    if mu < cur_mu:
        # mZ -> mb (5), mb -> mc (4), mc -> mu (3)
        path = [(cur_mu, mb, 5), (mb, mc, 4), (mc, mu, 3)]
    else:
        # mZ -> mu (5) if increasing (simple case)
        path = [(cur_mu, mu, 5)]


    for lo, hi, nf in path:
        cur_as = run_between(lo, hi, cur_as, nf)
        cur_mu = hi
    return cur_as


def alpha_em_const(mu: float) -> float:
    """Keep α ≈ α(mZ) as a small global correction (OK for first predictions)."""
    return ALPHA_mZ


# --------------- ln R factors and total residue f_q(μ) ---------------------------
def ln_R_qcd(mu_lo: float, mu_hi: float) -> float:
    """ln of mass-running factor from QCD only, using γ_m(4L) and αs(μ) on a log grid."""
    if mu_lo == mu_hi:
        return 0.0
    x0, x1 = math.log(mu_lo), math.log(mu_hi)
    nstep  = max(800, int(abs(x1 - x0) * 1600))
    s = 0.0
    for k in range(nstep):
        xm  = x0 + (x1 - x0) * (k + 0.5)/nstep
        mu  = math.exp(xm)
        nf  = nf_profile(mu)
        a_s = alpha_s_MSbar(mu) / math.pi
        s  += gamma_m_qcd_4L(a_s, nf) * (x1 - x0)/nstep
    return s


def ln_R_qed_2L(mu_lo: float, mu_hi: float, Qq: float) -> float:
    """ln R_QED with constant α(mZ); tiny but uniform."""
    if mu_lo == mu_hi:
        return 0.0
    alpha = alpha_em_const(MZ_GeV)
    g = gamma_m_qed_2L(alpha, Qq)
    return g * math.log(mu_hi / mu_lo)


def residue_total(mu_star: float, mu: float, Qq: float) -> float:
    return (ln_R_qcd(mu_star, mu) + ln_R_qed_2L(mu_star, mu, Qq)) / LNPHI


# --------------- Fixed-point solver: m = A φ^{ r + f(m) } ------------------------
def fixed_point_mass(name: str, A_B: float, r_i: int, mu_star: float, Qq: float,
                     tol: float = 1e-8, itmax: int = 200) -> float:
    m = A_B * (PHI ** r_i)  # structural seed
    for _ in range(itmax):
        f = residue_total(mu_star, m, Qq)
        m_new = A_B * (PHI ** (r_i + f))
        if abs(m_new - m)/max(1e-16, m) < tol:
            return m_new
        m = 0.5*m + 0.5*m_new
    return m


# --------------- Write the table --------------------------------------------------
def main():
    rows = []


    # Down sector (μ* = 2 GeV): d, s
    mu_d = PDG['d']['mu_star']; mu_s = PDG['s']['mu_star']
    m_d  = fixed_point_mass('d', A_D, R_DN['d'], mu_d, Q_DN['d'])
    m_s  = fixed_point_mass('s', A_D, R_DN['s'], mu_s, Q_DN['s'])
    rows.append(('d', mu_d, m_d, PDG['d']['ref'], 'MSbar@2GeV'))
    rows.append(('s', mu_s, m_s, PDG['s']['ref'], 'MSbar@2GeV'))


    # Up sector (μ* = 2 GeV): u
    mu_u = PDG['u']['mu_star']
    m_u  = fixed_point_mass('u', A_U, R_UP['u'], mu_u, Q_UP['u'])
    rows.append(('u', mu_u, m_u, PDG['u']['ref'], 'MSbar@2GeV'))


    # Heavy at their conventional μ*
    mu_c = PDG['c']['mu_star']; m_c = fixed_point_mass('c', A_U, R_UP['c'], mu_c, Q_UP['c'])
    mu_b = PDG['b']['mu_star']; m_b = fixed_point_mass('b', A_D, R_DN['b'], mu_b, Q_DN['b'])
    rows.append(('c', mu_c, m_c, PDG['c']['ref'], 'MSbar@m_c'))
    rows.append(('b', mu_b, m_b, PDG['b']['ref'], 'MSbar@m_b'))


    # If/when you want top now (choose scheme; set nf_profile to allow nf=6 above mt):
    # mu_t = PDG['t']['mu_star']; m_t = fixed_point_mass('t', A_U, R_UP['t'], mu_t, Q_UP['t'])
    # rows.append(('t', mu_t, m_t, PDG['t']['ref'], 'pole'))


    # Write CSV
    os.makedirs(os.path.join("out","csv"), exist_ok=True)
    csv_path = os.path.join("out","csv","quark_masses_muStar.csv")
    with open(csv_path, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["Species","mu_star_GeV","Pred_GeV","Ref_GeV","Scheme","Residual"])
        for sp, mu, mp, mr, sch in rows:
            resid = (mp - mr)/mr if mr else float('nan')
            w.writerow([sp, f"{mu:.6f}", f"{mp:.6f}", f"{mr:.6f}", sch, f"{resid:.6e}"])
    print(f"[OK] wrote {csv_path}")


    # Write TeX
    os.makedirs(os.path.join("out","tex"), exist_ok=True)
    tex_path = os.path.join("out","tex","quark_masses_muStar.tex")
    with open(tex_path, "w") as f:
        f.write("\\begin{center}\n\\begin{tabular}{lrrrrr}\n\\toprule\n")
        f.write("Species & $\\mu_\\star$ [GeV] & $\\widehat m$ [GeV] & $m$ (ref) [GeV] & Scheme & Residual \\\\\n\\midrule\n")
        for sp, mu, mp, mr, sch in rows:
            resid = (mp - mr)/mr if mr else float('nan')
            f.write(f"{sp} & {mu:.6f} & {mp:.6f} & {mr:.6f} & {sch} & {resid:.3e} \\\\\n")
        f.write("\\bottomrule\n\\end{tabular}\n\\end{center}\n")
    print(f"[OK] wrote {tex_path}")


if __name__ == "__main__":
    main()